---
layout: post
title: "Linux 系统状态监控（WIP）"
date: 2024-06-15 20:35:09 +0800
categories: post
---

### **引言**

今天想了解下 Linux 系统状态监控，写一些关于运维方面的内容，主要关注以下两个问题：

1. 如何判断当前服务器的运行状态是否正常？
2. 如何获取某一个的服务（进程）的资源占用情况？

### **查看 Linux 系统内核、发行版及硬件信息**

查看当前 Linux 系统的内核版本

``` Bash
uname -r
cat /proc/version
```

查看当前 Linux 系统属于哪一个发行版

``` Bash
cat /etc/os-release

# 只适用于支持 LSB（Linux Standard Base）的发行版，Arch、Gentoo 等发行版默认不支持 LSB
lsb_release -a
```

查看 CPU 信息

``` Bash
# 查看 CPU 信息
cat /proc/cpuinfo

# 查看 CPU 核心数量
grep -c 'model name' /proc/cpuinfo
```

查看内存大小及使用情况

``` Bash
free -h
cat /proc/meminfo
```

查看磁盘大小及使用情况

``` Bash
# 列出系统中文件系统的磁盘使用情况
# df 关注文件系统
df -h

# 查看某一个文件夹占用的磁盘大小
# df 关注文件
du -h -d 0 ${path_to_dir}

# 列出系统中所有块设备的信息，包括硬盘和分区
lsblk

# 列出系统中所有磁盘及分区的详细信息
sudo fdisk -l
```

### **系统监控**

#### **系统 CPU 与内存负载监控（top 工具）**

![top](/assets/imgs/top.png)

关于 Linux 系统状态监控，我最先想到的是 top（/usr/bin/top）工具，大多数 Linux 发行版都会预先安装这个工具，但我一直没有深入研究过。

top 工具可用于查看当前系统的运行情况，top 工具的默认输出可以分为上下两部分，上面部分是系统的运行情况（在 manual 中为 SUMMARY Display），下面部分是每个**任务**的运行情况（在 manual 中为 FIELDS / Columns）。

##### **SUMMARY Display**

``` Shell
# 可使用此命令查看这部分相关字段的说明
man -P "less -p '^2\.\sSUMMARY\sDisplay'" top
```

top 工具默认输出的第一行与 uptime（/usr/bin/uptime）工具的输出是一致的，关于 load average 可以参考[理解Linux系统负荷](https://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html)。

在 top 工具中，task（即 process 或 thread）被分为 running、sleeping、stopped 及 zombie 这 4 种状态。那为什么没有 ready 状态呢？在 manual 中能够找到下面表述，即 running 状态已包括 ready 状态。

> Tasks shown as running should be more properly thought of as ready to run.

- sleeping：在等待某个事件发生（I/O 事件）或某个条件满足的 task。
- stopped：可通过向进程发送`SIGSTOP`或`SIGTSTP`信号（即按`ctrl+z`）使其进入 stopped 状态，对于接收到`SIGTSTP`信号进入 stopped 状态的进程，可通过`jobs`命令查看，可通过向进程发送`SIGCONT`信号唤醒进程，命令`fg #id`可唤醒进程并在前台执行，命令`bg #id`可唤醒进程并在后台执行。
- zombie：task 已终止，但资源未被回收。

对于内存，top manual 未给出 buff/cache 及 avail Mem 的定义，这里具体可以参考`man free`。

- buff/cache：是 [kernel buffer](https://kernel.org/doc/html/v5.5/media/uapi/v4l/buffer.html#buffers)、[page cache](https://en.wikipedia.org/wiki/Page_cache) 及 [slab](https://en.wikipedia.org/wiki/Slab_allocation) 使用的内存总和。
- avail Mem：在不使用交换内存的前提下，可用于启动新应用程序的内存大小。

关于 avail Mem 有两个参考链接：

- [What do the "buff/cache" and "avail mem" fields in top mean?](https://unix.stackexchange.com/questions/390518/what-do-the-buff-cache-and-avail-mem-fields-in-top-mean)
- [How can I get the amount of available memory portably across distributions?](https://unix.stackexchange.com/questions/261247/how-can-i-get-the-amount-of-available-memory-portably-across-distributions)

##### **FIELDS / Columns**

> manual 中会经常看到 [SMP（对称多线程）](https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86)，比如在 SMP 环境下，进程的 %CPU 会大于 100。

``` Shell
# 可使用此命令查看这部分相关字段的说明
man -P "less -p '^3\.\sFIELDS\s/\sColumns'" top
```

- PR 代表优先级（Priority），如果为数字，越小优先级越高（默认为 20），如果为 rt，表示当前任务的优先级为 real time scheduling priority，具有比普通任务更高的优先级。
- RES 表示常驻内存大小（Resident Memory Size），当前任务所使用的非交换物理内存的大小。
- SHR 表示共享内存大小，可由多个任务共享，比如动态链接的共享库，共享内存不一定为常驻内存。
- VIRT 表示任务使用的虚拟内存总量，包括所有代码、数据和共享库，以及已交换出的页面和已映射但未使用的页面。

##### **一些小技巧**

- 按`f`可以进入配置界面，设置展示哪些字段，及按照哪个字段排序，具体可查看 manual 4.c 小节。
- 可以通过按`c`使列 Command 在 name 与 command line 模式间切换。
- 可以通过按`shift+h`可以切换为进程模式与线程模式间切换。

##### **补充**

[top-liked tool family in Linux](https://superuser.com/questions/469032/full-list-of-top-like-tool-family-for-perfomance-monitoring-in-linux-iftop-ioto)

#### **系统 I/O 负载监控（iotop 工具）**

![iotop](/assets/imgs/iotop.png)

iotop 工具可用于实时查看 I/O 负载，但可能需要手动安装，发行版可能不会预先安装。

iotop 工具的默认输出也同样分为上下两部分，上面部分是概要信息，下面部分是每个任务的 I/O 负载情况。iotop 的 manual 比较简单和清晰，后面对于每个部分的介绍就直接粘贴 manual 中的内容了。

##### **概要信息**

> From iotop manual
>
> - **Total DISK READ** and **Total DISK WRITE** values represent total read and write bandwidth between **processes and kernel threads** on the one side and **kernel block device subsystem** on the other.
> - **Actual DISK READ** and **Actual DISK WRITE** values represent corresponding bandwidths for actual disk I/O between **kernel block device subsystem** and **underlying hardware** (HDD, SSD, etc.).
> - Total and Actual values may not be equal at any given moment of time due to data caching and I/O operations reordering that take place inside Linux kernel.

##### **每个任务的 I/O 负载情况**

> From iotop manual
>
> iotop displays columns for the I/O bandwidth read and written by each process/thread during the sampling period. It also displays the percentage of time the thread/process spent while swapping in and while waiting on I/O. For each process, its I/O priority (class/level) is shown.

##### **一些小技巧**

- 排序：可以通过按左右箭头键更改排序字段，按`r`可以调整排序顺序（从大到小或从小到大）。
- 线程/进程模式：默认是线程模式，按`p`可以在两种模式间切换。

#### **系统的网络负载监控（iftop 工具）**

![iftop](/assets/imgs/iftop.png)

``` Bash
# 查看 eth0 网卡的网络负载
iftop -i eth0
```

可以通过 iftop 工具查看指定网卡的出入流量，及通过此网卡与相关站点通信的出入流量情况。iftop 工具的默认输出同样分为上下两部分，上下两部分最右侧的三列数据皆表示在 2s、10s 及 40s 内的统计值。下面部分的 cum 表示自 iftop 开始运行后的流量累计总和。

### **进程监控**

``` Bash
# 监控进程的 CPU 与内存负载
top -p ${pid}
htop -p ${pid}

# 监控进程的 I/O 负载
iotop -p ${pid}
```
